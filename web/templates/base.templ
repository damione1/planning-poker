package templates

import "github.com/damiengoehrig/planning-poker/internal/services"

templ Base(title string) {
	{{
		validator := services.NewVoteValidator()
		templatesData := validator.GetAvailableTemplates()
	}}
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>{ title } - Planning Poker</title>
			<link rel="stylesheet" href="/static/css/styles.css"/>
			<script src="/static/js/htmx.min.js"></script>
			<script src="/static/js/ws.js"></script>
			@templ.JSONScript("vote-templates-data", templatesData)
			<script>
			// Register Alpine components BEFORE Alpine loads
			document.addEventListener('alpine:init', () => {
				console.log('Alpine initializing - registering components');

				// ===================================================================
				// GLOBAL STATE STORE - Single source of truth for all room state
				// ===================================================================
				Alpine.store('roomState', {
					// Core room data
					roomId: null,
					roomState: 'voting', // 'voting' | 'revealed'
					roundNumber: 1,
					isCreator: false,
					expiresAt: null, // ISO 8601 timestamp

					// Participant data
					participants: [],
					currentParticipantId: null,

					// Vote tracking
					votes: new Map(), // participantId -> value
					currentUserVote: null,

					// WebSocket
					socketWrapper: null,

					// Computed properties (getters)
					get voteCount() {
						return this.votes.size;
					},

					get hasVotes() {
						return this.votes.size > 0;
					},

					get isExpired() {
						if (!this.expiresAt) return false;
						const now = new Date();
						const expiryDate = new Date(this.expiresAt);
						return now > expiryDate;
					},

					get canReveal() {
						return !this.isExpired && this.roomState === 'voting' && this.hasVotes;
					},

					get canReset() {
						return !this.isExpired && this.isCreator && (this.roomState === 'voting' && this.hasVotes || this.roomState === 'revealed');
					},

					get canNextRound() {
						return !this.isExpired && this.roomState === 'revealed';
					},

					// State management methods
					init(roomId, roomState, roundNumber, isCreator, currentParticipantId) {
						this.roomId = roomId;
						this.roomState = roomState || 'voting';
						this.roundNumber = roundNumber || 1;
						this.isCreator = isCreator || false;
						this.currentParticipantId = currentParticipantId;
						console.log('üè™ Global state initialized:', {
							roomId: this.roomId,
							roomState: this.roomState,
							roundNumber: this.roundNumber,
							isCreator: this.isCreator,
							currentParticipantId: this.currentParticipantId
						});
					},

					setSocketWrapper(wrapper) {
						this.socketWrapper = wrapper;
						console.log('üîå WebSocket wrapper set');
					},

					updateRoomState(newState) {
						console.log('üìä Room state changing:', this.roomState, '‚Üí', newState);
						this.roomState = newState;
					},

					updateRoundNumber(newRound) {
						console.log('üîÑ Round changing:', this.roundNumber, '‚Üí', newRound);
						this.roundNumber = newRound;
					},

					setParticipants(participants) {
						this.participants = participants || [];
						console.log('üë• Participants updated:', this.participants.length);
					},

					addVote(participantId, value) {
						this.votes.set(participantId, value);
						if (participantId === this.currentParticipantId) {
							this.currentUserVote = value;
						}
						console.log('üó≥Ô∏è Vote added:', participantId, '‚Üí', value, '(Total:', this.voteCount, ')');
					},

					clearVotes() {
						this.votes.clear();
						this.currentUserVote = null;
						console.log('üßπ All votes cleared');
					},

					resetForNewRound(newRoundNumber) {
						this.clearVotes();
						this.updateRoundNumber(newRoundNumber);
						this.updateRoomState('voting');
						console.log('üÜï Reset for new round:', newRoundNumber);
					},

					// WebSocket message handlers
					handleMessage(message) {
						console.log('üì® Global state handling message:', message.type);

						switch (message.type) {
							case 'room_state':
								this.handleRoomStateMessage(message.payload);
								break;
							case 'vote_cast':
								this.handleVoteCastMessage(message.payload);
								break;
							case 'votes_revealed':
								this.handleVotesRevealedMessage(message.payload);
								break;
							case 'vote_updated':
								this.handleVoteUpdatedMessage(message.payload);
								break;
							case 'room_reset':
								this.handleRoomResetMessage();
								break;
							case 'round_completed':
								this.handleRoundCompletedMessage(message.payload);
								break;
							case 'participant_joined':
							case 'participant_left':
								this.refreshParticipants();
								break;
							case 'name_updated':
								this.handleNameUpdatedMessage(message.payload);
								break;
							case 'room_name_updated':
								this.handleRoomNameUpdatedMessage(message.payload);
								break;
							case 'room_expired':
								this.handleRoomExpiredMessage(message.payload);
								break;
						}
					},

					handleRoomStateMessage(payload) {
						console.log('üìä Room state message:', payload);

						// Update core room state
						if (payload.roomState) {
							this.updateRoomState(payload.roomState);
						}
						if (payload.roundNumber) {
							this.updateRoundNumber(payload.roundNumber);
						}
						if (payload.participants) {
							this.setParticipants(payload.participants);
						}

						// Update expiration timestamp
						if (payload.expiresAt) {
							this.expiresAt = payload.expiresAt;
							console.log('‚è∞ Expiration time set:', this.expiresAt);
						}

						// Update creator flag
						if (payload.isCreator !== undefined) {
							this.isCreator = payload.isCreator;
							console.log('üéØ IsCreator flag set:', this.isCreator);
						}

						// Update current participant ID
						if (payload.currentParticipantId) {
							this.currentParticipantId = payload.currentParticipantId;
							console.log('üë§ Current participant ID set:', this.currentParticipantId);
						}

						// Initialize votes from vote count (we don't have individual votes yet)
						if (payload.voteCount !== undefined) {
							console.log('üó≥Ô∏è Initial vote count:', payload.voteCount);
							// We'll get individual votes from vote_cast messages
						}

						this.refreshParticipants();
					},

					handleVoteCastMessage(payload) {
						console.log('üó≥Ô∏è Vote cast message:', payload);
						if (payload.participantId && payload.hasVoted) {
							// Don't overwrite current user's vote (they already have the actual value)
							if (payload.participantId !== this.currentParticipantId) {
								this.addVote(payload.participantId, 'voted'); // Value hidden until reveal
							} else {
								// For current user, just update the vote map but preserve their actual vote
								this.votes.set(payload.participantId, this.currentUserVote || 'voted');
							}
						}
						this.refreshParticipants();
					},

					handleVotesRevealedMessage(payload) {
						console.log('üëÅÔ∏è Votes revealed message:', payload);
						this.updateRoomState('revealed');

						// Update votes with actual values
						if (payload.votes && Array.isArray(payload.votes)) {
							this.votes.clear();
							payload.votes.forEach(vote => {
								this.addVote(vote.participantId, vote.value);
							});
						}

						this.refreshParticipants();
					},

					handleVoteUpdatedMessage(payload) {
						console.log('üîÑ Vote updated message:', payload);
						// Update the vote in the map
						if (payload.participantId && payload.value) {
							this.addVote(payload.participantId, payload.value);
						}
						this.refreshParticipants();
					},

					handleRoomResetMessage() {
						console.log('üîÑ Room reset message');
						this.clearVotes();
						this.updateRoomState('voting');
						this.refreshParticipants();
					},

					handleRoundCompletedMessage(payload) {
						console.log('‚úÖ Round completed message:', payload);
						if (payload.newRoundNumber) {
							this.resetForNewRound(payload.newRoundNumber);
						}
						this.refreshParticipants();
					},

					handleNameUpdatedMessage(payload) {
						console.log('üë§ Name updated message:', payload);
						// Dispatch event for Alpine component to update
						window.dispatchEvent(new CustomEvent('name-updated', {
							detail: {
								participantId: payload.participantId,
								name: payload.name
							}
						}));
						this.refreshParticipants();
					},

					handleRoomNameUpdatedMessage(payload) {
						console.log('üè† Room name updated message:', payload);
						if (payload.name) {
							const roomNameElement = document.querySelector('h1');
							if (roomNameElement) {
								roomNameElement.textContent = payload.name;
							}
						}
					},

					handleRoomExpiredMessage(payload) {
						console.log('‚è∞ Room expired message:', payload);
						// Show alert to user
						alert(payload.message || 'This room has expired. You will be redirected to create a new room.');
						// Redirect to home page
						window.location.href = '/';
					},

					refreshParticipants() {
						if (!this.roomId) return;
						htmx.ajax('GET', `/room/${this.roomId}/participants`, {
							target: 'body',
							swap: 'none'
						});
					},

					// WebSocket send methods
					sendMessage(type, payload = {}) {
						// Check expiration for critical actions
						const criticalActions = ['vote', 'reveal', 'reset', 'next_round'];
						if (criticalActions.includes(type) && this.isExpired) {
							console.warn('‚è∞ Action blocked: room has expired');
							alert('This room has expired. Please create a new room.');
							window.location.href = '/';
							return false;
						}

						const message = JSON.stringify({ type, payload });
						if (this.socketWrapper && this.socketWrapper.send) {
							console.log('üì§ Sending message:', type, payload);
							this.socketWrapper.send(message);
							return true;
						} else {
							console.error('‚ùå WebSocket not available');
							return false;
						}
					},

					sendVote(value) {
						if (this.sendMessage('vote', { value })) {
							this.currentUserVote = value;
						}
					},

					sendReveal() {
						this.sendMessage('reveal');
					},

					sendReset() {
						this.sendMessage('reset');
					},

					sendNextRound() {
						this.sendMessage('next_round');
					}
				});

				// ===================================================================
				// COMPONENT: Room Form (Home page)
				// ===================================================================
				Alpine.data("roomForm", () => {
					// Load templates from server-injected JSON data
					const templatesEl = document.getElementById('vote-templates-data');
					const templatesArray = templatesEl ? JSON.parse(templatesEl.textContent) : [];

					// Build templates object from server data
					const templates = {};
					templatesArray.forEach(t => {
						templates[t.ID] = t.Values;
					});

					const defaultTemplate = templatesArray.length > 0 ? templatesArray[0].ID : 'modified-fibonacci';
					const defaultValues = templatesArray.length > 0 ? templatesArray[0].Values : '0.5, 1, 2, 3, 5, 8, 13, 20, 40, 100';

					return {
						pointingMethod: "custom",
						selectedTemplate: defaultTemplate,
						customValues: defaultValues,
						templates: templates,

						updateCustomValues() {
							if (this.templates[this.selectedTemplate]) {
								this.customValues = this.templates[this.selectedTemplate];
							}
						}
					};
				});

				// ===================================================================
				// COMPONENT: Room State Manager (Main room container)
				// ===================================================================
				Alpine.data("roomStateManager", () => ({
					init() {
						console.log('[DEBUG] roomStateManager init() called, element:', this.$el);

						// Extract room ID from WebSocket connection URL
						const wsUrl = this.$el.getAttribute('ws-connect');
						console.log('[DEBUG] ws-connect attribute value:', wsUrl);
						if (wsUrl) {
							const roomId = wsUrl.replace('/ws/', '');

							// Initialize global state (will be enriched by room_state message)
							this.$store.roomState.init(roomId);
						}

						// Listen for HTMX WebSocket events
						document.body.addEventListener("htmx:wsOpen", (event) => {
							console.log('[DEBUG] HTMX WebSocket opened');
							if (event.detail && event.detail.socketWrapper) {
								this.$store.roomState.setSocketWrapper(event.detail.socketWrapper);
							}
						});

						document.body.addEventListener("htmx:wsAfterMessage", (event) => {
							console.log('[DEBUG] HTMX WebSocket message received:', event.detail.message);
							try {
								const message = JSON.parse(event.detail.message);
								this.$store.roomState.handleMessage(message);
							} catch (err) {
								console.error("Failed to parse WebSocket message:", err);
							}
						});

						document.body.addEventListener("htmx:wsClose", (event) => {
							console.log('[DEBUG] HTMX WebSocket closed');
						});

						document.body.addEventListener("htmx:wsError", (event) => {
							console.error('[ERROR] HTMX WebSocket error:', event.detail);
						});
					},

					sendMessage(type, payload = {}) {
						return this.$store.roomState.sendMessage(type, payload);
					}
				}));

				// ===================================================================
				// COMPONENT: Card Selector (Voting cards)
				// ===================================================================
				Alpine.data("cardSelector", () => ({
					get selected() {
						return this.$store.roomState.currentUserVote;
					},

					selectCard(value) {
						console.log('Card selected:', value);
						// Check if room is expired before allowing vote
						if (this.$store.roomState.isExpired) {
							alert('This room has expired. Please create a new room.');
							window.location.href = '/';
							return;
						}
						// Allow voting in both 'voting' and 'revealed' states
						this.$store.roomState.sendVote(value);
					},

					get isVoting() {
						// Allow card selection in both voting and revealed states (unless expired)
						if (this.$store.roomState.isExpired) return false;
						const state = this.$store.roomState.roomState;
						return state === 'voting' || state === 'revealed';
					}
				}));

				// ===================================================================
				// COMPONENT: Room Controls (Reveal, Reset, Next Round buttons)
				// ===================================================================
				Alpine.data("roomControls", () => ({
					get canReveal() {
						return this.$store.roomState.canReveal;
					},

					get canReset() {
						return this.$store.roomState.canReset;
					},

					get canNextRound() {
						return this.$store.roomState.canNextRound;
					},

					get roomState() {
						return this.$store.roomState.roomState;
					},

					get voteCount() {
						return this.$store.roomState.voteCount;
					},

					sendReveal() {
						console.log('üîì Reveal button clicked');
						this.$store.roomState.sendReveal();
					},

					sendReset() {
						console.log('üîÑ Reset button clicked');
						this.$store.roomState.sendReset();
					},

					sendNextRound() {
						console.log('‚û°Ô∏è Next round button clicked');
						this.$store.roomState.sendNextRound();
					}
				}));

				// ===================================================================
				// COMPONENT: Room Sharing
				// ===================================================================
				Alpine.data("roomSharing", () => ({
					showQR: false,
					showShareModal: false,
					copied: false,
					async copyUrl() {
						try {
							await navigator.clipboard.writeText(window.location.href);
							this.copied = true;
							setTimeout(() => {
								this.copied = false;
							}, 2000);
						} catch (err) {
							console.error("Failed to copy:", err);
						}
					},
				}));

				// ===================================================================
				// COMPONENT: Expiration Countdown
				// ===================================================================
				Alpine.data("expirationCountdown", () => ({
					updateInterval: null,

					init() {
						// Watch for changes to expiresAt in the store
						this.$watch('$store.roomState.expiresAt', () => {
							// Force update when expiresAt changes
							this.$nextTick(() => {
								// Trigger Alpine to re-evaluate the getter
							});
						});

						// Update every minute
						this.updateInterval = setInterval(() => {
							// Force Alpine to re-evaluate the getter by triggering a micro-update
							this.$nextTick(() => {});
						}, 60000);
					},

					destroy() {
						if (this.updateInterval) {
							clearInterval(this.updateInterval);
						}
					},

					get timeRemaining() {
						const expiresAt = this.$store.roomState.expiresAt;
						if (!expiresAt) {
							return '';
						}

						const now = new Date();
						const expiryDate = new Date(expiresAt);
						const diff = expiryDate - now;

						if (diff <= 0) {
							return 'Expired';
						}

						const hours = Math.floor(diff / (1000 * 60 * 60));
						const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

						if (hours > 0) {
							return `${hours}h ${minutes}m`;
						} else {
							return `${minutes}m`;
						}
					}
				}));

				console.log('‚úÖ All Alpine components registered with global state store');
			});
		</script>
			<script defer src="https://unpkg.com/alpinejs@3.14.1/dist/cdn.min.js"></script>
		</head>
		<body class="min-h-screen bg-gray-50 font-sans antialiased">
			<div class="container mx-auto px-4 py-8 max-w-6xl">
				{ children... }
			</div>
		</body>
	</html>
}
