package templates

templ Base(title string) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>{title} - Planning Poker</title>
		<link rel="stylesheet" href="/static/css/styles.css"/>
		<script src="https://unpkg.com/htmx.org@2.0.0"></script>
		<script src="https://unpkg.com/htmx-ext-ws@2.0.0/ws.js"></script>
		<script>
			// Register Alpine components BEFORE Alpine loads
			document.addEventListener('alpine:init', () => {
				console.log('Alpine initializing - registering components');

				// ===================================================================
				// GLOBAL STATE STORE - Single source of truth for all room state
				// ===================================================================
				Alpine.store('roomState', {
					// Core room data
					roomId: null,
					roomState: 'voting', // 'voting' | 'revealed'
					roundNumber: 1,
					isCreator: false,

					// Participant data
					participants: [],
					currentParticipantId: null,

					// Vote tracking
					votes: new Map(), // participantId -> value
					currentUserVote: null,

					// WebSocket
					socketWrapper: null,

					// Computed properties (getters)
					get voteCount() {
						return this.votes.size;
					},

					get hasVotes() {
						return this.votes.size > 0;
					},

					get canReveal() {
						return this.roomState === 'voting' && this.hasVotes;
					},

					get canReset() {
						return this.isCreator && (this.roomState === 'voting' && this.hasVotes || this.roomState === 'revealed');
					},

					get canNextRound() {
						return this.roomState === 'revealed';
					},

					// State management methods
					init(roomId, roomState, roundNumber, isCreator, currentParticipantId) {
						this.roomId = roomId;
						this.roomState = roomState || 'voting';
						this.roundNumber = roundNumber || 1;
						this.isCreator = isCreator || false;
						this.currentParticipantId = currentParticipantId;
						console.log('🏪 Global state initialized:', {
							roomId: this.roomId,
							roomState: this.roomState,
							roundNumber: this.roundNumber,
							isCreator: this.isCreator,
							currentParticipantId: this.currentParticipantId
						});
					},

					setSocketWrapper(wrapper) {
						this.socketWrapper = wrapper;
						console.log('🔌 WebSocket wrapper set');
					},

					updateRoomState(newState) {
						console.log('📊 Room state changing:', this.roomState, '→', newState);
						this.roomState = newState;
					},

					updateRoundNumber(newRound) {
						console.log('🔄 Round changing:', this.roundNumber, '→', newRound);
						this.roundNumber = newRound;
					},

					setParticipants(participants) {
						this.participants = participants || [];
						console.log('👥 Participants updated:', this.participants.length);
					},

					addVote(participantId, value) {
						this.votes.set(participantId, value);
						if (participantId === this.currentParticipantId) {
							this.currentUserVote = value;
						}
						console.log('🗳️ Vote added:', participantId, '→', value, '(Total:', this.voteCount, ')');
					},

					clearVotes() {
						this.votes.clear();
						this.currentUserVote = null;
						console.log('🧹 All votes cleared');
					},

					resetForNewRound(newRoundNumber) {
						this.clearVotes();
						this.updateRoundNumber(newRoundNumber);
						this.updateRoomState('voting');
						console.log('🆕 Reset for new round:', newRoundNumber);
					},

					// WebSocket message handlers
					handleMessage(message) {
						console.log('📨 Global state handling message:', message.type);

						switch (message.type) {
							case 'room_state':
								this.handleRoomStateMessage(message.payload);
								break;
							case 'vote_cast':
								this.handleVoteCastMessage(message.payload);
								break;
							case 'votes_revealed':
								this.handleVotesRevealedMessage(message.payload);
								break;
							case 'vote_updated':
								this.handleVoteUpdatedMessage(message.payload);
								break;
							case 'room_reset':
								this.handleRoomResetMessage();
								break;
							case 'round_completed':
								this.handleRoundCompletedMessage(message.payload);
								break;
							case 'participant_joined':
							case 'participant_left':
								this.refreshParticipants();
								break;
						}
					},

					handleRoomStateMessage(payload) {
						console.log('📊 Room state message:', payload);

						// Update core room state
						if (payload.roomState) {
							this.updateRoomState(payload.roomState);
						}
						if (payload.roundNumber) {
							this.updateRoundNumber(payload.roundNumber);
						}
						if (payload.participants) {
							this.setParticipants(payload.participants);
						}

						// Update creator flag
						if (payload.isCreator !== undefined) {
							this.isCreator = payload.isCreator;
							console.log('🎯 IsCreator flag set:', this.isCreator);
						}

						// Update current participant ID
						if (payload.currentParticipantId) {
							this.currentParticipantId = payload.currentParticipantId;
							console.log('👤 Current participant ID set:', this.currentParticipantId);
						}

						// Initialize votes from vote count (we don't have individual votes yet)
						if (payload.voteCount !== undefined) {
							console.log('🗳️ Initial vote count:', payload.voteCount);
							// We'll get individual votes from vote_cast messages
						}

						this.refreshParticipants();
					},

					handleVoteCastMessage(payload) {
						console.log('🗳️ Vote cast message:', payload);
						if (payload.participantId && payload.hasVoted) {
							this.addVote(payload.participantId, 'voted'); // Value hidden until reveal
						}
						this.refreshParticipants();
					},

					handleVotesRevealedMessage(payload) {
						console.log('👁️ Votes revealed message:', payload);
						this.updateRoomState('revealed');

						// Update votes with actual values
						if (payload.votes && Array.isArray(payload.votes)) {
							this.votes.clear();
							payload.votes.forEach(vote => {
								this.addVote(vote.participantId, vote.value);
							});
						}

						this.refreshParticipants();
					},

					handleVoteUpdatedMessage(payload) {
						console.log('🔄 Vote updated message:', payload);
						// Update the vote in the map
						if (payload.participantId && payload.value) {
							this.addVote(payload.participantId, payload.value);
						}
						this.refreshParticipants();
					},

					handleRoomResetMessage() {
						console.log('🔄 Room reset message');
						this.clearVotes();
						this.updateRoomState('voting');
						this.refreshParticipants();
					},

					handleRoundCompletedMessage(payload) {
						console.log('✅ Round completed message:', payload);
						if (payload.newRoundNumber) {
							this.resetForNewRound(payload.newRoundNumber);
						}
						this.refreshParticipants();
					},

					refreshParticipants() {
						if (!this.roomId) return;
						htmx.ajax('GET', `/room/${this.roomId}/participants`, {
							target: 'body',
							swap: 'none'
						});
					},

					// WebSocket send methods
					sendMessage(type, payload = {}) {
						const message = JSON.stringify({ type, payload });
						if (this.socketWrapper && this.socketWrapper.send) {
							console.log('📤 Sending message:', type, payload);
							this.socketWrapper.send(message);
							return true;
						} else {
							console.error('❌ WebSocket not available');
							return false;
						}
					},

					sendVote(value) {
						if (this.sendMessage('vote', { value })) {
							this.currentUserVote = value;
						}
					},

					sendReveal() {
						this.sendMessage('reveal');
					},

					sendReset() {
						this.sendMessage('reset');
					},

					sendNextRound() {
						this.sendMessage('next_round');
					}
				});

				// ===================================================================
				// COMPONENT: Room Form (Home page)
				// ===================================================================
				Alpine.data("roomForm", () => ({
					pointingMethod: "fibonacci",
				}));

				// ===================================================================
				// COMPONENT: Room State Manager (Main room container)
				// ===================================================================
				Alpine.data("roomStateManager", () => ({
					init() {
						console.log('[DEBUG] roomStateManager init() called, element:', this.$el);

						// Extract room ID from WebSocket connection URL
						const wsUrl = this.$el.getAttribute('ws-connect');
						console.log('[DEBUG] ws-connect attribute value:', wsUrl);
						if (wsUrl) {
							const roomId = wsUrl.replace('/ws/', '');

							// Initialize global state (will be enriched by room_state message)
							this.$store.roomState.init(roomId);
						}

						// Listen for HTMX WebSocket events
						document.body.addEventListener("htmx:wsOpen", (event) => {
							console.log('[DEBUG] HTMX WebSocket opened');
							if (event.detail && event.detail.socketWrapper) {
								this.$store.roomState.setSocketWrapper(event.detail.socketWrapper);
							}
						});

						document.body.addEventListener("htmx:wsAfterMessage", (event) => {
							console.log('[DEBUG] HTMX WebSocket message received:', event.detail.message);
							try {
								const message = JSON.parse(event.detail.message);
								this.$store.roomState.handleMessage(message);
							} catch (err) {
								console.error("Failed to parse WebSocket message:", err);
							}
						});

						document.body.addEventListener("htmx:wsClose", (event) => {
							console.log('[DEBUG] HTMX WebSocket closed');
						});

						document.body.addEventListener("htmx:wsError", (event) => {
							console.error('[ERROR] HTMX WebSocket error:', event.detail);
						});
					}
				}));

				// ===================================================================
				// COMPONENT: Card Selector (Voting cards)
				// ===================================================================
				Alpine.data("cardSelector", () => ({
					get selected() {
						return this.$store.roomState.currentUserVote;
					},

					selectCard(value) {
						console.log('🃏 Card selected:', value);
						// Allow voting in both 'voting' and 'revealed' states
						this.$store.roomState.sendVote(value);
					},

					get isVoting() {
						// Allow card selection in both voting and revealed states
						const state = this.$store.roomState.roomState;
						return state === 'voting' || state === 'revealed';
					}
				}));

				// ===================================================================
				// COMPONENT: Room Controls (Reveal, Reset, Next Round buttons)
				// ===================================================================
				Alpine.data("roomControls", () => ({
					get canReveal() {
						return this.$store.roomState.canReveal;
					},

					get canReset() {
						return this.$store.roomState.canReset;
					},

					get canNextRound() {
						return this.$store.roomState.canNextRound;
					},

					get roomState() {
						return this.$store.roomState.roomState;
					},

					get voteCount() {
						return this.$store.roomState.voteCount;
					},

					sendReveal() {
						console.log('🔓 Reveal button clicked');
						this.$store.roomState.sendReveal();
					},

					sendReset() {
						console.log('🔄 Reset button clicked');
						this.$store.roomState.sendReset();
					},

					sendNextRound() {
						console.log('➡️ Next round button clicked');
						this.$store.roomState.sendNextRound();
					}
				}));

				// ===================================================================
				// COMPONENT: Room Sharing
				// ===================================================================
				Alpine.data("roomSharing", () => ({
					showQR: false,
					showShareModal: false,
					copied: false,
					async copyUrl() {
						try {
							await navigator.clipboard.writeText(window.location.href);
							this.copied = true;
							setTimeout(() => {
								this.copied = false;
							}, 2000);
						} catch (err) {
							console.error("Failed to copy:", err);
						}
					},
				}));

				console.log('✅ All Alpine components registered with global state store');
			});
		</script>
		<script defer src="https://unpkg.com/alpinejs@3.14.1/dist/cdn.min.js"></script>
	</head>
	<body class="min-h-screen bg-gray-50 font-sans antialiased">
		<div class="container mx-auto px-4 py-8 max-w-6xl">
			{ children... }
		</div>
	</body>
	</html>
}
