package templates

import "github.com/damione1/planning-poker-new/internal/models"
import "sort"
import "fmt"

// ParticipantGrid renders the participant grid WITHOUT hx-swap-oob (for initial page load)
templ ParticipantGrid(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	<div id="participants">
		@participantGridContent(participants, state, votes, currentParticipant)
	</div>
}

// ParticipantGridOOB renders the participant grid WITH hx-swap-oob (for WebSocket updates)
templ ParticipantGridOOB(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	<div id="participants" hx-swap-oob="true">
		@participantGridContent(participants, state, votes, currentParticipant)
	</div>
}

// participantGridContent is the shared content for both templates
templ participantGridContent(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	// Sort participants alphabetically and separate voters from spectators
	{{
		sortedParticipants := make([]*models.Participant, 0, len(participants))
		voters := make([]*models.Participant, 0)
		spectators := make([]*models.Participant, 0)

		for _, p := range participants {
			sortedParticipants = append(sortedParticipants, p)
		}
		sort.Slice(sortedParticipants, func(i, j int) bool {
			return sortedParticipants[i].Name < sortedParticipants[j].Name
		})

		// Separate voters and spectators
		for _, p := range sortedParticipants {
			if p.Connected {
				if p.Role == models.RoleVoter {
					voters = append(voters, p)
				} else if p.Role == models.RoleSpectator {
					spectators = append(spectators, p)
				}
			}
		}
	}}
	if len(voters) > 0 {
		<div class="mb-8">
			<h3 class="text-sm font-bold text-slate-600 uppercase tracking-wider mb-5">Participants</h3>
			<div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-6">
				for idx, p := range voters {
					{{
						isCurrentUser := currentParticipant != nil && p.ID == currentParticipant.ID
						vote, hasVoted := votes[p.ID]
						isRevealed := state == models.StateRevealed
					}}
					<div class="flex flex-col items-center gap-3">
						<!-- Card flip container -->
						<div class="relative w-24 h-32 card-flip-container">
							<!-- Card inner (flips) - Always starts with back showing, then animates to reveal if needed -->
							<div
								x-data="{ shouldFlip: false }"
								x-init={ fmt.Sprintf("setTimeout(() => { shouldFlip = %t }, 10)", isRevealed) }
								class={ "card-flip-inner", templ.KV("reveal-delay-" + fmt.Sprintf("%d", idx % 10), true) }
								:class="{ 'is-flipped': shouldFlip }"
							>
								<!-- Front face (value) - hidden until flip -->
								<div class="card-face card-face-front bg-white border-2 border-primary-400 rounded-xl flex items-center justify-center shadow-2xl">
									if hasVoted && isRevealed {
										<span class="text-4xl font-bold bg-gradient-to-br from-primary-600 to-success-600 bg-clip-text text-transparent">{ vote }</span>
									} else if !hasVoted && isRevealed {
										<span class="text-5xl">üí§</span>
									}
								</div>
								<!-- Back face (emoji) - visible initially -->
								<div
									class={ "card-face rounded-xl flex flex-col items-center justify-center border-2 shadow-xl transition-all",
									templ.KV("bg-gradient-to-br from-primary-50 to-success-50 border-primary-400", hasVoted),
									templ.KV("bg-white border-slate-300", !hasVoted) }
								>
									if hasVoted {
										<span class="text-5xl">üçÅ</span>
									} else {
										<span class="text-4xl text-slate-300">‚è≥</span>
									}
								</div>
							</div>
						</div>
						<!-- Name below card -->
						<div
							class={ "text-sm font-semibold text-center transition-colors",
							templ.KV("text-primary-700", isCurrentUser),
							templ.KV("text-slate-700", !isCurrentUser) }
						>{ p.Name }</div>
					</div>
				}
			</div>
		</div>
	}
	if len(spectators) > 0 {
		<div class="mt-8 pt-6 border-t border-gray-200">
			<h3 class="text-sm font-semibold text-gray-600 uppercase tracking-wider mb-3">Spectators</h3>
			<div class="flex flex-wrap gap-2">
				for _, p := range spectators {
					<span class="inline-block px-4 py-2 bg-gray-100 rounded-md text-gray-700 text-sm">{ p.Name }</span>
				}
			</div>
		</div>
	}
}
