package templates

import "github.com/damiengoehrig/planning-poker/internal/models"
import "sort"

// ParticipantGrid renders the participant grid WITHOUT hx-swap-oob (for initial page load)
templ ParticipantGrid(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	<div id="participants">
		@participantGridContent(participants, state, votes, currentParticipant)
	</div>
}

// ParticipantGridOOB renders the participant grid WITH hx-swap-oob (for WebSocket updates)
templ ParticipantGridOOB(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	<div id="participants" hx-swap-oob="true">
		@participantGridContent(participants, state, votes, currentParticipant)
	</div>
}

// participantGridContent is the shared content for both templates
templ participantGridContent(participants map[string]*models.Participant, state models.RoomState, votes map[string]string, currentParticipant *models.Participant) {
	// Sort participants alphabetically and separate voters from spectators
	{{
		sortedParticipants := make([]*models.Participant, 0, len(participants))
		voters := make([]*models.Participant, 0)
		spectators := make([]*models.Participant, 0)

		for _, p := range participants {
			sortedParticipants = append(sortedParticipants, p)
		}
		sort.Slice(sortedParticipants, func(i, j int) bool {
			return sortedParticipants[i].Name < sortedParticipants[j].Name
		})

		// Separate voters and spectators
		for _, p := range sortedParticipants {
			if p.Connected {
				if p.Role == models.RoleVoter {
					voters = append(voters, p)
				} else if p.Role == models.RoleSpectator {
					spectators = append(spectators, p)
				}
			}
		}
	}}
	if len(voters) > 0 {
		<div class="mb-6">
			<h3 class="text-sm font-semibold text-gray-600 uppercase tracking-wider mb-4">Participants</h3>
			<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
				for _, p := range voters {
					{{ isCurrentUser := currentParticipant != nil && p.ID == currentParticipant.ID }}
					<div class={ "text-center p-4 border-2 rounded-lg hover:shadow-md hover:-translate-y-1 transition-all",
						templ.KV("border-blue-400 bg-blue-50", isCurrentUser),
						templ.KV("border-gray-200 bg-gray-50", !isCurrentUser) }>
						<div class={ "w-20 h-20 mx-auto mb-3 text-white rounded-full flex items-center justify-center text-2xl font-bold",
							templ.KV("bg-blue-600", isCurrentUser),
							templ.KV("bg-gray-900", !isCurrentUser) }>
							if len(p.Name) > 0 {
								{p.Name[0:1]}
							}
						</div>
						<div class="font-semibold text-gray-900 mb-2">{p.Name}</div>
						<div class="mt-3">
							if vote, hasVoted := votes[p.ID]; hasVoted {
								if state == models.StateRevealed {
									<span class="text-2xl font-bold text-gray-900">{vote}</span>
								} else {
									<span class="text-2xl text-green-600">✓</span>
								}
							} else {
								<span class="text-2xl text-gray-400">⏱</span>
							}
						</div>
					</div>
				}
			</div>
		</div>
	}
	if len(spectators) > 0 {
		<div class="mt-8 pt-6 border-t border-gray-200">
			<h3 class="text-sm font-semibold text-gray-600 uppercase tracking-wider mb-3">Spectators</h3>
			<div class="flex flex-wrap gap-2">
				for _, p := range spectators {
					<span class="inline-block px-4 py-2 bg-gray-100 rounded-md text-gray-700 text-sm">{p.Name}</span>
				}
			</div>
		</div>
	}
}
