package templates

import "github.com/damione1/planning-poker-new/internal/services"

templ Base(title string) {
	{{
		validator := services.NewVoteValidator()
		templatesData := validator.GetAvailableTemplates()
	}}
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>{ title } - Planning Poker</title>
			<link rel="stylesheet" href="/static/css/styles.css"/>
			<style>
				/* Hide Alpine.js elements until initialized */
				[x-cloak] { display: none !important; }
			</style>
			<script src="/static/js/htmx.min.js"></script>
			<script src="/static/js/ws.js"></script>
			@templ.JSONScript("vote-templates-data", templatesData)
			<script>
			// Register Alpine components BEFORE Alpine loads
			document.addEventListener('alpine:init', () => {
				console.log('Alpine initializing - registering components');

				// ===================================================================
				// GLOBAL STATE STORE - Single source of truth for all room state
				// ===================================================================
				Alpine.store('roomState', {
					// Core room data
					roomId: null,
					roomState: 'voting', // 'voting' | 'revealed'
					roundNumber: 1,
					isCreator: false,
					expiresAt: null, // ISO 8601 timestamp

					// Participant data
					participants: [],
					currentParticipantId: null,

					// Permissions
					permissions: {
						canReveal: true,
						canReset: true,
						canNewRound: true,
						canChangeVoteAfterReveal: false
					},

					// Vote tracking
					votes: new Map(), // participantId -> value
					currentUserVote: null,

					// WebSocket connection management
					socketWrapper: null,
					connectionState: 'connecting', // 'connecting' | 'connected' | 'reconnecting' | 'disconnected'
					reconnectAttempts: 0,
					hasEverConnected: false, // Track if we've successfully connected before
					pendingMessages: [], // Queue messages during reconnection

					// Computed properties (getters)
					get voteCount() {
						return this.votes.size;
					},

					get hasVotes() {
						return this.votes.size > 0;
					},

					get isExpired() {
						if (!this.expiresAt) return false;
						const now = new Date();
						const expiryDate = new Date(this.expiresAt);
						return now > expiryDate;
					},

					get canReveal() {
						return !this.isExpired && this.roomState === 'voting' && this.hasVotes && this.permissions.canReveal;
					},

					get canReset() {
						return !this.isExpired && (this.roomState === 'voting' && this.hasVotes || this.roomState === 'revealed') && this.permissions.canReset;
					},

					get canNextRound() {
						return !this.isExpired && this.roomState === 'revealed' && this.permissions.canNewRound;
					},

					get isConnected() {
						return this.connectionState === 'connected';
					},

					get isReconnecting() {
						return this.connectionState === 'reconnecting';
					},

					get showConnectionBadge() {
						// Only show badge for reconnections (not initial connection) or disconnections
						return (this.connectionState === 'reconnecting' && this.hasEverConnected) ||
						       this.connectionState === 'disconnected';
					},

					// State management methods
					init(roomId, roomState, roundNumber, isCreator, currentParticipantId) {
						this.roomId = roomId;
						this.roomState = roomState || 'voting';
						this.roundNumber = roundNumber || 1;
						this.isCreator = isCreator || false;
						this.currentParticipantId = currentParticipantId;
						console.log('ðŸª Global state initialized:', {
							roomId: this.roomId,
							roomState: this.roomState,
							roundNumber: this.roundNumber,
							isCreator: this.isCreator,
							currentParticipantId: this.currentParticipantId
						});
					},

					setSocketWrapper(wrapper) {
						this.socketWrapper = wrapper;
						this.connectionState = 'connected';
						this.reconnectAttempts = 0;
						this.hasEverConnected = true; // Mark as having successfully connected
						console.log('ðŸ”Œ WebSocket wrapper set, connection established');

						// Process any pending messages
						this.processPendingMessages();
					},

					setConnectionState(state) {
						const oldState = this.connectionState;
						this.connectionState = state;
						console.log(`ðŸ”Œ Connection state: ${oldState} â†’ ${state}`);

						// Connection status shown by persistent badge - only toast for positive feedback
						if (state === 'connected' && oldState === 'reconnecting') {
							this.showToast('Connection restored', 'success');
						}
					},

					processPendingMessages() {
						if (this.pendingMessages.length === 0) return;

						console.log(`ðŸ“¤ Processing ${this.pendingMessages.length} pending messages`);
						const messages = [...this.pendingMessages];
						this.pendingMessages = [];

						messages.forEach(({ type, payload }) => {
							this.sendMessage(type, payload);
						});
					},

					showToast(message, type = 'info') {
						// Simple toast notification
						const toast = document.createElement('div');
						toast.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg text-white z-50 transition-opacity duration-300 ${
							type === 'success' ? 'bg-green-500' :
							type === 'warning' ? 'bg-yellow-500' :
							type === 'error' ? 'bg-red-500' :
							'bg-blue-500'
						}`;
						toast.textContent = message;
						document.body.appendChild(toast);

						// Auto-remove after 3 seconds
						setTimeout(() => {
							toast.style.opacity = '0';
							setTimeout(() => toast.remove(), 300);
						}, 3000);
					},

					updateRoomState(newState) {
						console.log('ðŸ“Š Room state changing:', this.roomState, 'â†’', newState);
						this.roomState = newState;
					},

					updateRoundNumber(newRound) {
						console.log('ðŸ”„ Round changing:', this.roundNumber, 'â†’', newRound);
						this.roundNumber = newRound;
					},

					setParticipants(participants) {
						this.participants = participants || [];
						console.log('ðŸ‘¥ Participants updated:', this.participants.length);
					},

					addVote(participantId, value) {
						this.votes.set(participantId, value);
						if (participantId === this.currentParticipantId) {
							this.currentUserVote = value;
						}
						console.log('ðŸ—³ï¸ Vote added:', participantId, 'â†’', value, '(Total:', this.voteCount, ')');
					},

					clearVotes() {
						this.votes.clear();
						this.currentUserVote = null;
						console.log('ðŸ§¹ All votes cleared');
					},

					resetForNewRound(newRoundNumber) {
						this.clearVotes();
						this.updateRoundNumber(newRoundNumber);
						this.updateRoomState('voting');
						console.log('ðŸ†• Reset for new round:', newRoundNumber);
					},

					// WebSocket message handlers
					handleMessage(message) {
						console.log('ðŸ“¨ Global state handling message:', message.type);

						switch (message.type) {
							case 'room_state':
								this.handleRoomStateMessage(message.payload);
								break;
							case 'vote_cast':
								this.handleVoteCastMessage(message.payload);
								break;
							case 'votes_revealed':
								this.handleVotesRevealedMessage(message.payload);
								break;
							case 'vote_updated':
								this.handleVoteUpdatedMessage(message.payload);
								break;
							case 'room_reset':
								this.handleRoomResetMessage();
								break;
							case 'round_completed':
								this.handleRoundCompletedMessage(message.payload);
								break;
							case 'participant_joined':
							case 'participant_left':
								this.refreshParticipants();
								break;
							case 'name_updated':
								this.handleNameUpdatedMessage(message.payload);
								break;
							case 'room_name_updated':
								this.handleRoomNameUpdatedMessage(message.payload);
								break;
							case 'room_expired':
								this.handleRoomExpiredMessage(message.payload);
								break;
							case 'config_updated':
								this.handleConfigUpdatedMessage(message.payload);
								break;
						}
					},

					handleRoomStateMessage(payload) {
						console.log('ðŸ“Š Room state message:', payload);

						// Update core room state
						if (payload.roomState) {
							this.updateRoomState(payload.roomState);
						}
						if (payload.roundNumber) {
							this.updateRoundNumber(payload.roundNumber);
						}
						if (payload.participants) {
							this.setParticipants(payload.participants);
						}

						// Update expiration timestamp
						if (payload.expiresAt) {
							this.expiresAt = payload.expiresAt;
							console.log('â° Expiration time set:', this.expiresAt);
						}

						// Update creator flag
						if (payload.isCreator !== undefined) {
							this.isCreator = payload.isCreator;
							console.log('ðŸŽ¯ IsCreator flag set:', this.isCreator);
						}

						// Update current participant ID
						if (payload.currentParticipantId) {
							this.currentParticipantId = payload.currentParticipantId;
							console.log('ðŸ‘¤ Current participant ID set:', this.currentParticipantId);
						}

						// Initialize votes from vote count (we don't have individual votes yet)
						if (payload.voteCount !== undefined) {
							console.log('ðŸ—³ï¸ Initial vote count:', payload.voteCount);
							// We'll get individual votes from vote_cast messages
						}

						// Update permissions from room state
						if (payload.permissions) {
							console.log('ðŸ” Permissions received:', payload.permissions);
							// Store permissions for button states
							this.permissions = payload.permissions;
						}

						this.refreshParticipants();
					},

					handleVoteCastMessage(payload) {
						console.log('ðŸ—³ï¸ Vote cast message:', payload);
						if (payload.participantId && payload.hasVoted) {
							// Don't overwrite current user's vote (they already have the actual value)
							if (payload.participantId !== this.currentParticipantId) {
								this.addVote(payload.participantId, 'voted'); // Value hidden until reveal
							} else {
								// For current user, just update the vote map but preserve their actual vote
								this.votes.set(payload.participantId, this.currentUserVote || 'voted');
							}
						}
						this.refreshParticipants();
					},

					handleVotesRevealedMessage(payload) {
						console.log('ðŸ‘ï¸ Votes revealed message:', payload);
						this.updateRoomState('revealed');

						// Update votes with actual values
						if (payload.votes && Array.isArray(payload.votes)) {
							this.votes.clear();
							payload.votes.forEach(vote => {
								this.addVote(vote.participantId, vote.value);
							});
						}

						this.refreshParticipants();
					},

					handleVoteUpdatedMessage(payload) {
						console.log('ðŸ”„ Vote updated message:', payload);
						// Update the vote in the map
						if (payload.participantId && payload.value) {
							this.addVote(payload.participantId, payload.value);
						}
						this.refreshParticipants();
					},

					handleRoomResetMessage() {
						console.log('ðŸ”„ Room reset message');
						this.clearVotes();
						this.updateRoomState('voting');
						this.refreshParticipants();
					},

					handleRoundCompletedMessage(payload) {
						console.log('âœ… Round completed message:', payload);
						if (payload.newRoundNumber) {
							this.resetForNewRound(payload.newRoundNumber);
						}
						this.refreshParticipants();
					},

					handleNameUpdatedMessage(payload) {
						console.log('ðŸ‘¤ Name updated message:', payload);
						// Dispatch event for Alpine component to update
						window.dispatchEvent(new CustomEvent('name-updated', {
							detail: {
								participantId: payload.participantId,
								name: payload.name
							}
						}));
						this.refreshParticipants();
					},

					handleRoomNameUpdatedMessage(payload) {
						console.log('ðŸ  Room name updated message:', payload);
						if (payload.name) {
							const roomNameElement = document.querySelector('h1');
							if (roomNameElement) {
								roomNameElement.textContent = payload.name;
							}
						}
					},

					handleRoomExpiredMessage(payload) {
						console.log('â° Room expired message:', payload);
						// Show alert to user
						alert(payload.message || 'This room has expired. You will be redirected to create a new room.');
						// Redirect to home page
						window.location.href = '/';
					},

					handleConfigUpdatedMessage(payload) {
						console.log('âš™ï¸ Config updated message:', payload);
						if (payload.config) {
							// Update the settings store with new config
							Alpine.store('roomSettings').updateFromServer(payload.config);

							// Recalculate permissions based on new config and current user's creator status
							this.updatePermissionsFromConfig(payload.config);

							this.showToast('Room settings updated', 'success');
						}
					},

					updatePermissionsFromConfig(config) {
						// Recalculate permissions based on config and whether current user is creator
						const isCreator = this.isCreator;

						// Creator always has all permissions
						if (isCreator) {
							this.permissions = {
								canReveal: true,
								canReset: true,
								canNewRound: true,
								canChangeVoteAfterReveal: config.permissions.allow_change_vote_after_reveal
							};
						} else {
							// Non-creators permissions based on config
							this.permissions = {
								canReveal: config.permissions.allow_all_reveal,
								canReset: config.permissions.allow_all_reset,
								canNewRound: config.permissions.allow_all_new_round,
								canChangeVoteAfterReveal: config.permissions.allow_change_vote_after_reveal
							};
						}

						console.log('ðŸ” Permissions recalculated:', this.permissions);
					},

					refreshParticipants() {
						if (!this.roomId) return;
						htmx.ajax('GET', `/room/${this.roomId}/participants`, {
							target: 'body',
							swap: 'none'
						});
					},

					// WebSocket send methods
					sendMessage(type, payload = {}) {
						// Check expiration for critical actions
						const criticalActions = ['vote', 'reveal', 'reset', 'next_round'];
						if (criticalActions.includes(type) && this.isExpired) {
							console.warn('â° Action blocked: room has expired');
							alert('This room has expired. Please create a new room.');
							window.location.href = '/';
							return false;
						}

						const message = JSON.stringify({ type, payload });

						// If not connected, queue the message for later
						if (!this.socketWrapper || !this.isConnected) {
							console.warn('â³ Connection not available, queueing message:', type);
							this.pendingMessages.push({ type, payload });
							this.showToast('Action queued, will send when reconnected', 'info');
							return false;
						}

						// Send immediately if connected
						console.log('ðŸ“¤ Sending message:', type, payload);
						this.socketWrapper.send(message);
						return true;
					},

					sendVote(value) {
						if (this.sendMessage('vote', { value })) {
							this.currentUserVote = value;
						}
					},

					sendReveal() {
						this.sendMessage('reveal');
					},

					sendReset() {
						this.sendMessage('reset');
					},

					sendNextRound() {
						this.sendMessage('next_round');
					}
				});

				// ===================================================================
				// COMPONENT: Room Form (Home page)
				// ===================================================================
				Alpine.data("roomForm", () => {
					// Load templates from server-injected JSON data
					const templatesEl = document.getElementById('vote-templates-data');
					const templatesArray = templatesEl ? JSON.parse(templatesEl.textContent) : [];

					// Build templates object from server data
					const templates = {};
					templatesArray.forEach(t => {
						templates[t.ID] = t.Values;
					});

					const defaultTemplate = templatesArray.length > 0 ? templatesArray[0].ID : 'modified-fibonacci';
					const defaultValues = templatesArray.length > 0 ? templatesArray[0].Values : '0.5, 1, 2, 3, 5, 8, 13, 20, 40, 100';

					return {
						selectedTemplate: defaultTemplate,
						customValues: defaultValues,
						templates: templates,

						updateCustomValues() {
							if (this.templates[this.selectedTemplate]) {
								this.customValues = this.templates[this.selectedTemplate];
							}
						}
					};
				});

				// ===================================================================
				// COMPONENT: Room State Manager (Main room container)
				// ===================================================================
				Alpine.data("roomStateManager", () => ({
					init() {
						console.log('[DEBUG] roomStateManager init() called, element:', this.$el);

						// Extract room ID from WebSocket connection URL
						const wsUrl = this.$el.getAttribute('ws-connect');
						console.log('[DEBUG] ws-connect attribute value:', wsUrl);
						if (wsUrl) {
							const roomId = wsUrl.replace('/ws/', '');

							// Initialize global state (will be enriched by room_state message)
							this.$store.roomState.init(roomId);
						}

						// Listen for HTMX WebSocket events
						document.body.addEventListener("htmx:wsConnecting", (event) => {
							console.log('[DEBUG] HTMX WebSocket connecting');
							// Only set to 'reconnecting' if we've connected before
							// Otherwise, keep it as 'connecting' for the initial connection
							if (this.$store.roomState.hasEverConnected) {
								this.$store.roomState.setConnectionState('reconnecting');
								this.$store.roomState.reconnectAttempts++;
							}
						});

						document.body.addEventListener("htmx:wsOpen", (event) => {
							console.log('[DEBUG] HTMX WebSocket opened');
							if (event.detail && event.detail.socketWrapper) {
								this.$store.roomState.setSocketWrapper(event.detail.socketWrapper);
							}
						});

						document.body.addEventListener("htmx:wsAfterMessage", (event) => {
							console.log('[DEBUG] HTMX WebSocket message received:', event.detail.message);
							try {
								const message = JSON.parse(event.detail.message);
								this.$store.roomState.handleMessage(message);
							} catch (err) {
								console.error("Failed to parse WebSocket message:", err);
							}
						});

						document.body.addEventListener("htmx:wsClose", (event) => {
							console.log('[DEBUG] HTMX WebSocket closed', event.detail);
							// Set to reconnecting - htmx will automatically retry
							this.$store.roomState.setConnectionState('reconnecting');
						});

						document.body.addEventListener("htmx:wsError", (event) => {
							console.error('[ERROR] HTMX WebSocket error:', event.detail);
							this.$store.roomState.setConnectionState('reconnecting');
						});
					},

					sendMessage(type, payload = {}) {
						return this.$store.roomState.sendMessage(type, payload);
					}
				}));

				// ===================================================================
				// COMPONENT: Card Selector (Voting cards)
				// ===================================================================
				Alpine.data("cardSelector", () => ({
					get selected() {
						return this.$store.roomState.currentUserVote;
					},

					selectCard(value) {
						console.log('Card selected:', value);

						// Check if voting is allowed (this will be false when disabled)
						if (!this.isVoting) {
							console.warn('Cannot vote: voting is disabled');
							return;
						}

						// Check if room is expired before allowing vote
						if (this.$store.roomState.isExpired) {
							alert('This room has expired. Please create a new room.');
							window.location.href = '/';
							return;
						}

						// Check if connected before allowing vote
						if (!this.$store.roomState.isConnected) {
							console.warn('Cannot vote while disconnected');
							return;
						}

						// Send the vote
						this.$store.roomState.sendVote(value);
					},

					get isVoting() {
						// Check if voting is allowed based on room state and permissions
						if (this.$store.roomState.isExpired) return false;
						if (!this.$store.roomState.isConnected) return false;

						const state = this.$store.roomState.roomState;

						// Always allow voting in 'voting' state
						if (state === 'voting') return true;

						// In 'revealed' state, check if changing votes is allowed
						if (state === 'revealed') {
							return this.$store.roomState.permissions.canChangeVoteAfterReveal;
						}

						return false;
					}
				}));

				// ===================================================================
				// COMPONENT: Room Controls (Reveal, Reset, Next Round buttons)
				// ===================================================================
				Alpine.data("roomControls", () => ({
				// Visibility getters (permission-only for x-show)
				get showReveal() {
					return this.$store.roomState.permissions.canReveal;
				},
				get showReset() {
					return this.$store.roomState.permissions.canReset;
				},
				get showNextRound() {
					return this.$store.roomState.permissions.canNewRound;
				},

				// Enabled state getters (all conditions for :disabled)
				get canReveal() {
						return this.$store.roomState.canReveal;
					},

					get canReset() {
						return this.$store.roomState.canReset;
					},

					get canNextRound() {
						return this.$store.roomState.canNextRound;
					},

					get roomState() {
						return this.$store.roomState.roomState;
					},

					get voteCount() {
						return this.$store.roomState.voteCount;
					},

					sendReveal() {
						console.log('ðŸ”“ Reveal button clicked');
						this.$store.roomState.sendReveal();
					},

					sendReset() {
						console.log('ðŸ”„ Reset button clicked');
						this.$store.roomState.sendReset();
					},

					sendNextRound() {
						console.log('âž¡ï¸ Next round button clicked');
						this.$store.roomState.sendNextRound();
					}
				}));

				// ===================================================================
				// GLOBAL STATE STORE - Room Settings
				// ===================================================================
				Alpine.store('roomSettings', {
					showModal: false,
					config: {
						permissions: {
							allow_all_reveal: true,
							allow_all_reset: true,
							allow_all_new_round: true
						}
					},

					init(initialConfig) {
						if (initialConfig && initialConfig.permissions) {
							this.config = initialConfig;
						}
					},

					updateFromServer(serverConfig) {
						this.config = serverConfig;
						console.log('âš™ï¸ Room config updated from server:', this.config);
					}
				});

				// ===================================================================
				// COMPONENT: Room Settings (Creator only)
				// ===================================================================
				Alpine.data("roomSettings", () => ({
					get config() {
						return this.$store.roomSettings.config;
					},

					set config(value) {
						this.$store.roomSettings.config = value;
					},

					saveConfig() {
						console.log('ðŸ’¾ Saving room config:', this.config);
						// Send config update via WebSocket
						if (this.$store.roomState.sendMessage('update_config', { config: this.config })) {
							this.$store.roomSettings.showModal = false;
							this.$store.roomState.showToast('Settings saved successfully', 'success');
						} else {
							this.$store.roomState.showToast('Failed to save settings. Please try again.', 'error');
						}
					}
				}));

				// ===================================================================
				// COMPONENT: Room Sharing
				// ===================================================================
				Alpine.data("roomSharing", () => ({
					showQR: false,
					showShareModal: false,
					copied: false,
					async copyUrl() {
						try {
							await navigator.clipboard.writeText(window.location.href);
							this.copied = true;
							setTimeout(() => {
								this.copied = false;
							}, 2000);
						} catch (err) {
							console.error("Failed to copy:", err);
						}
					},
				}));

				// ===================================================================
				// COMPONENT: Expiration Countdown
				// ===================================================================
				Alpine.data("expirationCountdown", () => ({
					updateInterval: null,

					init() {
						// Watch for changes to expiresAt in the store
						this.$watch('$store.roomState.expiresAt', () => {
							// Force update when expiresAt changes
							this.$nextTick(() => {
								// Trigger Alpine to re-evaluate the getter
							});
						});

						// Update every minute
						this.updateInterval = setInterval(() => {
							// Force Alpine to re-evaluate the getter by triggering a micro-update
							this.$nextTick(() => {});
						}, 60000);
					},

					destroy() {
						if (this.updateInterval) {
							clearInterval(this.updateInterval);
						}
					},

					get timeRemaining() {
						const expiresAt = this.$store.roomState.expiresAt;
						if (!expiresAt) {
							return '';
						}

						const now = new Date();
						const expiryDate = new Date(expiresAt);
						const diff = expiryDate - now;

						if (diff <= 0) {
							return 'Expired';
						}

						const hours = Math.floor(diff / (1000 * 60 * 60));
						const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

						if (hours > 0) {
							return `${hours}h ${minutes}m`;
						} else {
							return `${minutes}m`;
						}
					}
				}));

				console.log('âœ… All Alpine components registered with global state store');
			});
		</script>
			<script defer src="https://unpkg.com/alpinejs@3.14.1/dist/cdn.min.js"></script>
		</head>
		<body class="min-h-screen bg-gradient-to-br from-slate-50 via-primary-50/30 to-slate-100 font-sans antialiased">
			<div class="container mx-auto px-4 py-8 max-w-6xl">
				{ children... }
			</div>
		</body>
	</html>
}
